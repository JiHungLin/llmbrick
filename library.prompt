LLMBrick: Comprehensive Guide to Custom Brick Development and Library Usage

Overview and Purpose
LLMBrick is a modular Python framework designed to solve the challenges of building, composing, and deploying advanced LLM (Large Language Model) applications. It addresses the need for reusable, composable, and maintainable AI components by introducing the concept of “Bricks”—well-defined, pluggable modules that encapsulate specific logic, workflows, or integrations. LLMBrick enables rapid prototyping, scalable deployment, and robust error handling for LLM-powered systems.

Core Features
- Modular Brick system: Each Brick is a self-contained component for tasks like intent detection, text correction, retrieval, translation, or integrating external APIs.
- Standardized protocols: Unified request/response types, error handling, and streaming support (unary, input/output/bidirectional streaming).
- Service deployment: Bricks can be exposed as gRPC or SSE services for distributed or real-time applications.
- Extensibility: Easily create custom Bricks or extend built-in ones.
- Async/await support for high concurrency and non-blocking operations.
- Built-in error codes, logging, and performance monitoring utilities.

Brick System: Base Bricks and Their Interfaces

LLMBrick provides several base Bricks, each designed for a specific NLP or orchestration task. All Bricks inherit from a common interface and expose a set of standard handler functions. Below is an overview of the main base Bricks, their request/response types, and customizable functions:

1. **CommonBrick**
   - Purpose: General-purpose base for custom Bricks.
   - Handlers: 
     - `run_unary(request: CommonRequest) -> CommonResponse`
     - `run_input_streaming(request_stream: AsyncIterable[CommonRequest]) -> CommonResponse`
     - `run_output_streaming(request: CommonRequest) -> AsyncIterable[CommonResponse]`
     - `run_bidi_streaming(request_stream: AsyncIterable[CommonRequest]) -> AsyncIterable[CommonResponse]`
     - `run_get_service_info() -> ServiceInfo`
   - Request: `CommonRequest` (data: dict, metadata: dict)
   - Response: `CommonResponse` (data: dict, error: ErrorDetail)
   - Customizable: Override any handler, add custom logic, define new methods.

2. **LLMBrick**
   - Purpose: Integrate and manage LLM (e.g., OpenAI) calls.
   - Handlers:
     - `run_unary(request: LLMRequest) -> LLMResponse`
     - `run_output_streaming(request: LLMRequest) -> AsyncIterable[LLMResponse]`
   - Request: `LLMRequest` (prompt, context, parameters)
   - Response: `LLMResponse` (text, tokens, error)
   - Customizable: Model selection, prompt engineering, output formatting.

3. **ComposeBrick**
   - Purpose: Orchestrate multiple Bricks in a pipeline or workflow.
   - Handlers:
     - `run_unary(request: ComposeRequest) -> ComposeResponse`
   - Request: `ComposeRequest` (steps, data)
   - Response: `ComposeResponse` (results, error)
   - Customizable: Define step logic, data flow, error handling between Bricks.

4. **GuardBrick**
   - Purpose: Input validation, filtering, and safety checks.
   - Handlers:
     - `run_unary(request: GuardRequest) -> GuardResponse`
   - Request: `GuardRequest` (input, rules)
   - Response: `GuardResponse` (is_valid, reason, error)
   - Customizable: Validation rules, filtering logic.

5. **IntentionBrick**
   - Purpose: Intent detection and classification.
   - Handlers:
     - `run_unary(request: IntentionRequest) -> IntentionResponse`
   - Request: `IntentionRequest` (text, context)
   - Response: `IntentionResponse` (intent, confidence, error)
   - Customizable: Intent schema, classification logic.

6. **RectifyBrick**
   - Purpose: Text correction and normalization.
   - Handlers:
     - `run_unary(request: RectifyRequest) -> RectifyResponse`
   - Request: `RectifyRequest` (text, language)
   - Response: `RectifyResponse` (corrected_text, error)
   - Customizable: Correction algorithms, language support.

7. **RetrievalBrick**
   - Purpose: Information retrieval from knowledge bases or documents.
   - Handlers:
     - `run_unary(request: RetrievalRequest) -> RetrievalResponse`
   - Request: `RetrievalRequest` (query, top_k, filters)
   - Response: `RetrievalResponse` (documents, scores, error)
   - Customizable: Retrieval backend, ranking logic.

8. **TranslateBrick**
   - Purpose: Multilingual translation.
   - Handlers:
     - `run_unary(request: TranslateRequest) -> TranslateResponse`
   - Request: `TranslateRequest` (text, source_lang, target_lang)
   - Response: `TranslateResponse` (translated_text, error)
   - Customizable: Supported languages, translation engine.

Handler Decorators and Customization
- `@unary_handler`: For single request/response logic.
- `@input_streaming_handler`: For processing a stream of input requests.
- `@output_streaming_handler`: For streaming multiple outputs from a single request.
- `@bidi_streaming_handler`: For bidirectional streaming scenarios.
- `@get_service_info_handler`: For exposing Brick metadata and capabilities.

All handlers are async and can be overridden to implement custom logic. You can add additional methods or properties as needed.

Request/Response Data Types
- All Bricks use standardized request/response types, typically with a `.data` dictionary for inputs/outputs and an `error` field for status.
- Refer to the protocols in `llmbrick.protocols.models.bricks` for detailed type definitions.

Extending and Customizing Bricks
- Inherit from any base Brick to add or override handler methods.
- Document the expected input/output schema for your Brick.
- Compose Bricks for complex workflows using ComposeBrick or by chaining outputs/inputs.

Service Deployment and Integration
- Register any Brick as a gRPC or SSE service for distributed or real-time applications.
- Configure service parameters (host, port, etc.) as needed.

Quick Example: Minimal Brick
```python
from llmbrick.bricks.common.common import CommonBrick
from llmbrick.core.brick import unary_handler
from llmbrick.protocols.models.bricks.common_types import CommonRequest, CommonResponse, ErrorDetail
from llmbrick.core.error_codes import ErrorCodes

class HelloBrick(CommonBrick):
    @unary_handler
    async def hello(self, request: CommonRequest) -> CommonResponse:
        name = request.data.get("name", "World")
        return CommonResponse(
            data={"message": f"Hello, {name}!"},
            error=ErrorDetail(code=ErrorCodes.SUCCESS, message="Success")
        )
```
Test locally:
```python
import asyncio
from hello_brick import HelloBrick
from llmbrick.protocols.models.bricks.common_types import CommonRequest

async def main():
    brick = HelloBrick()
    req = CommonRequest(data={"name": "Alice"})
    resp = await brick.hello(req)
    print(resp.data["message"])  # Output: Hello, Alice!

if __name__ == "__main__":
    asyncio.run(main())
```

Service Deployment Example (gRPC)
```python
from llmbrick.servers.grpc.server import GrpcServer
from hello_brick import HelloBrick

brick = HelloBrick()
server = GrpcServer(port=50051)
server.register_service(brick)
server.run()
```

Service Deployment Example (SSE)
```python
from llmbrick.servers.sse import SSEServer
from hello_brick import HelloBrick

brick = HelloBrick()
server = SSEServer(brick, host="0.0.0.0", port=8000, enable_test_page=True)
server.run()
```

Advanced Brick Composition Example
```python
from llmbrick.bricks.guard.base_guard import GuardBrick
from llmbrick.bricks.rectify.base_rectify import RectifyBrick
from llmbrick.bricks.intention.base_intention import IntentionBrick
from llmbrick.bricks.llm.base_llm import LLMBrick

guard_brick = GuardBrick()
rectify_brick = RectifyBrick()
intention_brick = IntentionBrick()
llm_brick = LLMBrick()

async def main():
    result1 = await guard_brick.run_unary(guard_request)
    rectify_text = await rectify_brick.run_unary(rectify_request)
    intention_result = await intention_brick.run_unary(rectify_text)
    async for answer in llm_brick.run_output_streaming(question_context):
        print(answer)
```

Exception Handling and Using ErrorCodes

LLMBrick provides a robust error handling mechanism using standardized error codes and the `ErrorDetail` structure. Each response includes an `error` field, which contains a code and message. The `llmbrick.core.error_codes.ErrorCodes` module defines common error codes such as `SUCCESS`, `INVALID_INPUT`, `NOT_FOUND`, `INTERNAL_ERROR`, etc.

How to Use ErrorCodes in Your Brick:
- Always set the appropriate error code and message in your response.
- Use try/except blocks in your handler methods to catch exceptions and return meaningful error information.
- For custom errors, define your own codes or use the provided ones for consistency.

Example: Error Handling in a Custom Brick
```python
from llmbrick.core.error_codes import ErrorCodes

class MyCustomBrick(CommonBrick):
    @unary_handler
    async def process(self, request: CommonRequest) -> CommonResponse:
        try:
            user_input = request.data.get("input", "")
            if not user_input:
                return CommonResponse(
                    data={},
                    error=ErrorDetail(code=ErrorCodes.INVALID_INPUT, message="Input is required")
                )
            # Your logic here
            result = user_input.upper()
            return CommonResponse(
                data={"result": result},
                error=ErrorDetail(code=ErrorCodes.SUCCESS, message="Success")
            )
        except Exception as e:
            return CommonResponse(
                data={},
                error=ErrorDetail(code=ErrorCodes.INTERNAL_ERROR, message=str(e))
            )
```
- Always check the `error` field in the response when consuming a Brick’s output.
- Use error codes to implement retry logic, user feedback, or escalation as needed.